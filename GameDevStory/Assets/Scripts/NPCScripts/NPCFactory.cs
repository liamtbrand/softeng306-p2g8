using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

/// Because NPCs need to be hired, they are not initially instantiated in
/// the game world. To hire an NPC the NPC's attributes and statistics need
/// to be known. The NPCFactory manages the instantiation of NPCInfo objects
/// which are later used to create NPCS.
/// The NPCFactory has the responsiblity of generating randomised statistics
/// for each NPC, as well as ensuring no NPC is duplicated in-game.
/// The NPCInfo object can later be used to instantiate the NPC.
public class NPCFactory : Singleton<NPCFactory> {

    // The data structure for storing NPC stats.
    // These are randomly generated by the npc factory
    public class NPCStats
    {
        public int Communication;
        public int Testing;
        public int Technical;
        public int Creativity;
        public int Design;
    }

    // A pool of pre-made NPCs that are available for instantiation
    public List<NPCAttributes> Npcs;

    // Temporary pool to store attributes that have been removed from the main
    // pool. This is used to prevent the same npc from showing twice on the
    // hiring screen. The contents of the pool will be restored to the main
    // pool when an npc has been hired.
    private List<NPCAttributes> AttributePool = new List<NPCAttributes>();

    // determines how significant the gender pay gap is.
    // Could change as the game progresses, eventually achieving equal pay
    public float FemalePayMultiplier = 0.75f;

    // fields defining the range of values for the NPC costs
    public readonly int MinEmployeeCost = 40;
    public readonly int MaxEmployeeCost = 200;

    public double NumberOfFemales = 0;
    public int FemaleCount = 0;                 // Remember how many females we
                                                // have produces since the last
                                                // hiring advertisement

    public void SetNumberOfFemales(int Females)
    {
        FemaleCount = 0;
        NumberOfFemales = Females;
    }

    // selects a pre-made npc at random from the pool of potential npcs
    public NPCAttributes SelectRandomNPC()
    {
        return Npcs[Random.Range(0,Npcs.Count)];
    }

    // selects a pre-made npc at random from the pool of potential npcs
    // such that the npc is of the given gender.
    public NPCAttributes SelectRandomNPC(NPCAttributes.Gender gender)
    {
        List<NPCAttributes> subSelection = new List<NPCAttributes>();
        foreach(NPCAttributes attr in Npcs)
        {
            if(attr.gender == gender) {
                subSelection.Add(attr);
            }
        }
        return subSelection[Random.Range(0, subSelection.Count)];
    }

    // generates a stats object with all fields randomly initialized
    public NPCStats GetRandomStats()
    {
        NPCStats stats = new NPCStats
        {
            Communication = Random.Range(1, 101),
            Creativity = Random.Range(1, 101),
            Testing = Random.Range(1, 101),
            Technical = Random.Range(1, 101),
            Design = Random.Range(1, 101)
        };

        return stats;
    }

    // Creates an NPCInfo object with randomised statistics.
    public NPCInfo CreateNPCWithRandomizedStats()
    {
        NPCStats randomStats = GetRandomStats();
        NPCAttributes randomNPC = SelectRandomNPC(
            FemaleCount++ > NumberOfFemales
            ? NPCAttributes.Gender.MALE
            : NPCAttributes.Gender.FEMALE
        );

        NPCInfo npc = new NPCInfo()
        {
            Attributes = randomNPC,
            Stats = GetRandomStats()
        };

        // Here we remove the npc from the available ones and stick it into
        // the temporary pool for hiring from.
        Npcs.Remove(randomNPC);
        AttributePool.Add(randomNPC);

        npc.Attributes.cost = CalculateEmployeeCost(npc);
        npc.Attributes.costThreshold = CalculateCostThreshold(npc);
        npc.Attributes.negotiationFrustration = 0;
        npc.Attributes.ammountPaidFor = 0;

        return npc;
    }

    // This was created so that the NPCController can notify the NPCFactory
    // that an npc was hired. When we hire an npc, we never want them
    // to reappear as an applicant. We do however want to reuse applicants
    // so that we do not need to create too many npcprefabs.
    public void RemoveNPCFromPool(NPCInfo npcInfo)
    {
        // Ensure that this npc cannot be generated again (npcs are unique).
        AttributePool.Remove(npcInfo.Attributes);
        // This also implies that if an npc ever left, the leave would be final.

        ResetPool();
    }

    // Called to reset the pool of possible npcs.
    public void ResetPool()
    {
        // Restore all the attributes to the main pool.
        foreach(NPCAttributes attribute in AttributePool)
        {
            Npcs.Add(attribute);
        }

        // Clean up the temporary pool
        AttributePool.Clear();
    }

    // helper method to calculate the cost of employees based on their stats
    //TODO: and the player's current balance
    private int CalculateEmployeeCost(NPCInfo npc)
    {
        // work with float until the end where we will round
        float cost = 0;

        // each of the stats is worth an equal amount, and when added together must be within the
        // range of potential employee costs
        float minStatCost = MinEmployeeCost / 5f;
        float maxStatCost = MaxEmployeeCost / 5f;

        int npcCount = NPCController.Instance.NpcInstances.Count;
        float multiplier = (npcCount / 50f) + 1;

        minStatCost *= multiplier;
        maxStatCost *= multiplier;

        NPCStats stats = npc.Stats;

        cost += PercentBetween(minStatCost, maxStatCost, stats.Communication);
        cost += PercentBetween(minStatCost, maxStatCost, stats.Testing);
        cost += PercentBetween(minStatCost, maxStatCost, stats.Technical);
        cost += PercentBetween(minStatCost, maxStatCost, stats.Creativity);
        cost += PercentBetween(minStatCost, maxStatCost, stats.Design);

        if (npc.Attributes.gender.Equals(NPCAttributes.Gender.FEMALE))
            cost *= FemalePayMultiplier;

        return Mathf.RoundToInt(cost);
    }

    // Here we want to set the threshold to be a random number slightly lower than or equal to the
    // applicant's advertised cost. We subtract the absolute value generated from a gaussian
    // distribution scaled by 10% of the applicant's advertised cost. For example if we have an
    // applicant that advertises at $90, then their threshold will be:
    //
    //                  90 - 9 * [abs. of rand. gaussian value]
    //
    // This allows for very unlikely cases where the threshold for the applicant is incredibly low,
    // however their threshold is more likely to be very slightly under their advertised cost.
    private int CalculateCostThreshold(NPCInfo npc)
    {
        // Using the Marsaglia polar method to generate gaussian distributed numbers. Taken from
        // https://www.alanzucconi.com/2015/09/16/how-to-sample-from-a-gaussian-distribution/
        float v1, v2, s;
        do
        {
            v1 = 2.0f * Random.Range(0f, 1f) - 1.0f;
            v2 = 2.0f * Random.Range(0f, 1f) - 1.0f;
            s = v1 * v1 + v2 * v2;
        } while (s >= 1.0f || s == 0f);

        s = Mathf.Sqrt((-2.0f * Mathf.Log(s)) / s);
        var gaussianVar = v1 * s;

        // Get the cost of the npc and calculate their threshold using formula above
        var NpcCost = npc.Attributes.cost;
        return Mathf.CeilToInt(NpcCost - (NpcCost * 0.1f * Mathf.Abs(gaussianVar)));
    }

    // helper to give the value that is percent between min and max.
    // e.g PercentBetween(0,10,50) = 5 as 5 is halfway between 0 and 10
    private float PercentBetween(float min, float max, int percent)
    {
        float offset = (max - min) * percent / 100;
        return min + offset;
    }
}
